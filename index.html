<!doctype html>
<meta charset="utf-8">
<title>Baked Hourglass Viewer</title>
<style>
  :root { --bg:#0b0c10; --text:#e8ecf1; --muted:#9aa3ad; --accent:#4fc3f7; }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px system-ui}
  header{display:grid;grid-template-columns:auto 1fr;gap:10px;padding:10px;border-bottom:1px solid #20232b}
  .row{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  label{color:var(--muted)}
  select,input[type="text"]{background:#11131a;border:1px solid #1f2430;color:var(--text);border-radius:8px;padding:6px 8px}
  select{min-width:240px}
  input[type="range"]{width:220px}
  button{background:#141823;border:1px solid #2a2f3a;color:var(--text);border-radius:10px;padding:6px 10px;cursor:pointer}
  .wrap{display:grid;place-items:center;height:calc(100vh - 96px)}
  canvas{background:radial-gradient(1200px 700px at 50% 15%,rgba(255,255,255,.04),transparent 60%),#0b0c10;border:1px solid #1b1f28;border-radius:16px;width:min(900px,98vw);height:calc(min(900px,98vw)*1.1)}
  .time{min-width:110px;text-align:center;color:var(--muted);font-variant-numeric:tabular-nums}
  .bar{display:flex;align-items:center;gap:8px}
  #scrub{width:min(700px, 60vw)}
</style>

<header>
  <div class="row">
    <strong>Baked Hourglass</strong>
    <label>Variant
      <select id="variant">
        <option value="" disabled selected>— loading index (bakes/index.json) —</option>
      </select>
    </label>
    <button id="reloadIndex">Reload index</button>
    <button id="pp">Play</button>
    <label>Speed <input id="speed" type="range" min="0.25" max="2" step="0.05" value="1"></label>
  </div>
  <div class="row bar">
    <span class="time" id="time">00:00 / 00:00</span>
    <input id="scrub" type="range" min="0" max="1" value="0" step="1">
    <label>URL <input id="url" type="text" placeholder="bakes/hourglass_60s_neck16_k1.0_full0.9.json"></label>
    <button id="loadUrl">Open</button>
    <label>File <input id="file" type="file" accept=".json"></label>
  </div>
</header>

<div class="wrap"><canvas id="cv"></canvas></div>

<script>
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const sel = document.getElementById('variant');
const btnPP = document.getElementById('pp');
const speedEl = document.getElementById('speed');
const scrub = document.getElementById('scrub');
const timeEl = document.getElementById('time');

let bake=null, data=null, frame=0, playing=false, lastT=performance.now(), speed=1;
let scrubbing=false, wasPlaying=false;

function fit(){
  const DPR = Math.max(1, Math.min(2, devicePixelRatio||1));
  const cssW = Math.min(900, innerWidth*0.98), cssH = cssW*1.1;
  cv.style.width = cssW + 'px'; cv.style.height = cssH + 'px';
  cv.width = Math.round(cssW * DPR); cv.height = Math.round(cssH * DPR);
  return { DPR, cssW, cssH };
}
let view = fit(); addEventListener('resize', ()=>view=fit());

function widthAtY(y, meta){
  const {H, bulb, neck, k} = meta;
  const t = Math.min(1, Math.abs(y)/H);
  return neck + (bulb - neck) * Math.pow(t, k ?? 1.05);
}

function drawGlass(ctx, meta, DPR){
  const {H} = meta;
  ctx.save();
  ctx.lineWidth = Math.max(1.5, 2*DPR/2);
  ctx.strokeStyle = "rgba(255,255,255,0.16)";
  const steps = 72;

  // left
  ctx.beginPath();
  for (let i=0;i<=steps;i++){
    const t = -H + i*(2*H/steps);
    const x = -widthAtY(t, meta);
    (i===0) ? ctx.moveTo(x,t) : ctx.lineTo(x,t);
  }
  ctx.stroke();

  // right
  ctx.beginPath();
  for (let i=0;i<=steps;i++){
    const t = -H + i*(2*H/steps);
    const x =  widthAtY(t, meta);
    (i===0) ? ctx.moveTo(x,t) : ctx.lineTo(x,t);
  }
  ctx.stroke();

  // caps
  ctx.beginPath();
  ctx.moveTo(-widthAtY(-H, meta), -H);
  ctx.lineTo( widthAtY(-H, meta), -H);
  ctx.moveTo(-widthAtY( H, meta),  H);
  ctx.lineTo( widthAtY( H, meta),  H);
  ctx.stroke();

  // neck guide
  ctx.strokeStyle = "rgba(79,195,247,0.28)";
  ctx.beginPath(); ctx.moveTo(-meta.neck,0); ctx.lineTo(meta.neck,0); ctx.stroke();

  ctx.restore();
}

function fmtTime(sec){
  sec = Math.max(0, Math.round(sec));
  const m = (sec/60)|0, s = String(sec%60).padStart(2,'0');
  return `${String(m).padStart(2,'0')}:${s}`;
}
function updateTimeUI(){
  if(!bake){ timeEl.textContent = "00:00 / 00:00"; return; }
  const cur = frame / bake.meta.fps;
  const total = (bake.meta.frames-1) / bake.meta.fps;
  timeEl.textContent = `${fmtTime(cur)} / ${fmtTime(total)}`;
}

async function loadURL(url){
  const res = await fetch(url);
  bake = await res.json();
  const buf = Uint8Array.from(atob(bake.data), c=>c.charCodeAt(0)).buffer;
  data = new Uint16Array(buf);
  frame = 0; lastT = performance.now();
  scrub.max = String(bake.meta.frames - 1);
  scrub.value = "0";
  updateTimeUI();
  playing = true; btnPP.textContent = "Pause";
}
async function loadFile(file){
  const txt = await file.text();
  bake = JSON.parse(txt);
  const buf = Uint8Array.from(atob(bake.data), c=>c.charCodeAt(0)).buffer;
  data = new Uint16Array(buf);
  frame = 0; lastT = performance.now();
  scrub.max = String(bake.meta.frames - 1);
  scrub.value = "0";
  updateTimeUI();
  playing = true; btnPP.textContent = "Pause";
}

async function loadIndex(){
  try{
    const res = await fetch('bakes/index.json', {cache:'no-store'});
    if(!res.ok) throw new Error(res.statusText);
    const list = await res.json();
    sel.innerHTML = "";
    for(const e of list){
      const opt = document.createElement('option');
      opt.value = e.file;
      opt.textContent = e.label || e.file;
      sel.appendChild(opt);
    }
    if(list.length>0){
      sel.selectedIndex = 0;
    }
  }catch(e){
    // fallback single placeholder if index missing
    sel.innerHTML = `<option value="" disabled selected>No bakes/index.json found</option>`;
  }
}

function draw(){
  if(!bake) return;
  const {DPR, cssW, cssH} = view;
  const {fps, grains, frames, Q, H, bulb, r} = bake.meta;

  ctx.setTransform(DPR,0,0,DPR,0,0);
  ctx.clearRect(0,0,cssW,cssH);
  ctx.save(); ctx.translate(cssW/2, cssH/2);

  drawGlass(ctx, bake.meta, DPR);

  ctx.fillStyle = "rgba(244,143,177,0.96)";
  ctx.beginPath();
  const base = (frame|0) * grains * 2;
  for(let i=0;i<grains;i++){
    const x = data[base + i*2]     / Q - bulb - 5;
    const y = data[base + i*2 + 1] / Q - H    - 5;
    ctx.moveTo(x + r, y); ctx.arc(x, y, r, 0, Math.PI*2);
  }
  ctx.fill();

  ctx.restore();
}

function loop(){
  requestAnimationFrame(loop);
  if(!bake) return;
  const now = performance.now(), dt = (now - lastT)/1000; lastT = now;
  if(playing && !scrubbing){
    frame += speed * dt * bake.meta.fps;
    if(frame >= bake.meta.frames) frame = bake.meta.frames - 0.001; // hold final
    scrub.value = String(frame|0);
    updateTimeUI();
  }
  draw();
}

// UI wires
document.getElementById('reloadIndex').onclick = loadIndex;
sel.onchange = () => { const v = sel.value; if(v) loadURL(v); };

btnPP.onclick = () => { playing = !playing; btnPP.textContent = playing ? "Pause" : "Play"; };
speedEl.oninput = e => (speed = +e.target.value);

document.getElementById('loadUrl').onclick = () => {
  const u = document.getElementById('url').value.trim();
  if(u) loadURL(u);
};
document.getElementById('file').onchange = e => {
  const f = e.target.files?.[0]; if(f) loadFile(f);
};

// scrubber interactions
scrub.addEventListener('pointerdown', () => { scrubbing = true; wasPlaying = playing; playing = false; });
scrub.addEventListener('pointerup',   () => { scrubbing = false; playing = wasPlaying; });
scrub.addEventListener('input', () => {
  if(!bake) return;
  frame = +scrub.value;
  updateTimeUI();
  draw();
});

// query params: ?bake=... (and optional ?index=...)
const params = new URLSearchParams(location.search);
const indexOverride = params.get('index');
const bakeUrl = params.get('bake');

(async () => {
  if(indexOverride){
    // try custom index first
    try{
      const res = await fetch(indexOverride, {cache:'no-store'});
      const list = await res.json();
      sel.innerHTML = "";
      for(const e of list){
        const opt = document.createElement('option');
        opt.value = e.file;
        opt.textContent = e.label || e.file;
        sel.appendChild(opt);
      }
    }catch{}
  }else{
    await loadIndex();
  }

  if(bakeUrl){
    await loadURL(bakeUrl);
    // select it in the dropdown if present
    const opt = [...sel.options].find(o => o.value === bakeUrl);
    if(opt) sel.value = bakeUrl;
  }
  loop();
})();
</script>
